;Parsnip
;================:
;\\     /\       :
; \\   //\\      :
;  \\ //  \\     :
;   \\/----\\    :
;   //\----//\   :
;  // \\  // \\  :
; //   \\//   \\ :
;//     \/     \\:
;================:
;Project.........Parsnip
;Program.........Parsnip
;Author..........Zeda Thomas (ThunderBolt)
;E-mail..........xedaelnara@gmail.com
;Size............
;Language........English
;Programming.....Assembly
;Version.........v0.50            ;I rarely update this info
;Last Update.....23 December 2018     ;This is not accurate, probably

#define bcall(x) rst 28h \ .dw x
#define LCDDelay()   in a,(16) \ rla \ jr c,$-3
#include "parsnip.inc"
#define Coord(y,x)     .db 01,y,x
#define SHELL_BROKEN
#define speed
;for x,y,$ffff never stops
#define K_DELAY_DEFAULT 13
#define K_DELAY_ACCEL 3
#define ALIGN_COMMAND_TABLE      ;Comment this to potentially save some bytes, uncomment to save some clock cycles
;#define include_LoadTSA
#define STACK_SAFE               ;Makes the stack routines verify that they aren't overflowing

#define char_TI_TOK
fmtDigits = 97B0h
#define EXTERNAL_FORMAT_LEN    ;Uses an external reference to get the format length
#define EXTERNAL_FORMAT_LEN_LOC fmtDigits    ;Use for TI-OS


.org $4000
.db $80,$0F, 0,0,0,0
.db $80,$12, $01,$04    ;signing key ID
.db $80,$47, "Parsnip"  ;change the $47 according to name len.
.db $80,$81, 2          ;num pages
.db $80,$90             ;no splash
.db $03,$22,$09,$00     ;date stamp
.db $02,$00             ;date stamp signature
.db $80,$70             ;final field

     jp main
jumptable:
#include "jmptable.z80"
SelectedProg:
  bcall(_OP5ToOP1)

SelectedProgOP1:
  ld hl,gbuf
  ld (buf_ptr),hl
  bcall(_ChkFindSym)
  ret c
  ld hl,cmdShadow+2
  ld a,$BB
  cp (hl)
  jr nz,+_
  inc l
  ld a,$6D
  cp (hl)
  jp z,EndHook_prepush
_:
  ld a,(temp_word_3)
  or a
  jr z,ExecOP1
;Here we need to move the code to RAM.
;Put the name in OP1
  ld hl,GramTempName
  rst rMov9ToOP1

;Now we create the var
  ld a,16h
  ld hl,(temp_word_4)
  bcall(_CreateVar)
  inc de
  inc de

;Copy the source to RAM
;If size is 0, just exit.
  ld bc,(temp_word_4)
  ld a,b
  or c
  jr nz,+_
  pop hl
  ret
_:

  ld hl,(temp_word_5)
  ld a,(temp_word_3)
  call nz,ReadArc

;Now we copy the temp var's name back to OP1 and call it good :)
  ld hl,OP4
  rst rMov9ToOP1



ExecOP1:
  ld hl,OP1
  ld de,basic_prog
  call mov9_p0
  bcall(_ChkFindSym)
  ld a,b
  ret c
  or a
  ret nz
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
parse_via_ptr:
;HL points to code
;BC is the size
  ld (parsePtr),hl
  ld (progStart),hl
  add hl,bc
  ld (progEnd),hl
grazh:
  call SetUpData
  call progmeta
  call heap_init
  di
  ld hl,BreakProgram
  push hl
ParserNext:
  bit OnBlockFlag,(iy+UserFlags)
  call z,CheckStatus
  call z,err_ON
  ld de,ParserNext
  push de
ParseArg:
  ld de,(parsePtr)
  ld hl,(progEnd)
  scf
  sbc hl,de
  jr c,end_of_program
  ex de,hl

ParseArg2:
  ld a,(hl)
  inc hl
  ld (parsePtr),hl
  ex de,hl
#ifdef ALIGN_COMMAND_TABLE
  ld h,CommandJumpTable>>8
  add a,a
  ld l,a
  jr nc,+_
  inc h
_:
  rra
#else
  ld c,a
  ld hl,CommandJumpTable
  ld b,0
  add hl,bc
  add hl,bc
#endif
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ex de,hl
  ret
end_of_program:
  call exec_newline
  jp StopToken

_:
  dec a
  call opstackprecedence

exec_newline:
;need to pop and evaluate the stack
  ld hl,(opstack_ptr)
  xor a
  cp (hl)
  jr nz,-_

_:
;Either 0 or 1 operands should be left on the stack!
;Return if there are no operands left
  call isoperandstack_empty
  ret z

;There is an operand, so pop it into Ans
  call popoperand_ui16
  ld (Ans),de

;Now if there are any more operands, throw an error
  call isoperandstack_empty
  ret z
  call err_too_many_args

isoperandstack_empty:
  or a
  ld hl,(operandstack_ptr)
  ld de,(operandstack_bottom)
  sbc hl,de
  ret


exec_goto:
;WARNING:
;   This routine needs to verify that the stack and opstack don't have anything.
  ld de,(progStart)
;HL points to the label name
;DE points to where to begin searching
  push hl
  ld hl,(progEnd)
  or a
  sbc hl,de
  ld b,h
  ld c,l
  pop hl
;HL points to the label name
;DE points to where to begin searching
;BC is the number of bytes to search
  ex de,hl
  call searchlabel
  jp nz,err_label_not_found
  ld (parsePtr),hl
  ret

exec_end:
; First verify that we have a 0 on the opstack

  ld hl,(opstack_ptr)
  ld a,(hl)
  or a
  jp nz,err_syntax
  inc hl
  ld a,(hl)
  cp $D2    ;Repeat token
  jp nz,err_fatal
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl

  push hl   ;points to the top of the OP stack if done
  ld hl,(parsePtr)
  push hl
  ld (parsePtr),de  ;points to the condition

_:
; Parse the condition
  call parseArg
  ld hl,(parsePtr)
  ld a,(hl)
  sub $3E
  and $FE
  jr nz,-_
  inc hl
  ld (parsePtr),hl
;now make sure process th stuff on the opstack
  ld a,254
_:
  call opstackprecedence
  jr nc,-_

  call popoperand_bool
  pop de
  pop hl
  ret z
  ld (opstack_ptr),hl
  ld (parsePtr),de
  ret

exec_lbl:
seek_EOL:
  ld a,(hl)
  inc hl
  sub $3E     ; colon
  and $FE
  jr nz,exec_lbl
  ld (parsePtr),hl
  ret

exec_sqr:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  ld c,a
  cp type_var
  call z,peekvar
  ld a,c
  ld hl,eval_sqr_LUT
  jp jumptableindex

exec_inv:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  ld c,a
  cp type_var
  call z,peekvar
  ld a,c
  ld hl,eval_inv_LUT
  jp jumptableindex

exec_cubed:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  ld c,a
  cp type_var
  call z,peekvar
  ld a,c
  ld hl,eval_cubed_LUT
  jp jumptableindex

exec_repeat:
; Need to push HL to the operator stack, this points to the expression
; need to push the repeat token to the operator stack
; need to push a 0 to the operator stack
; skip to the end of the line
; execute as normal

  ex de,hl
  ld hl,(opstack_ptr)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  dec hl
  ld (hl),$D2
  dec hl
  ld (hl),$00
  ld (opstack_ptr),hl
  ex de,hl
  jr seek_EOL



exec_comma:
;evaluate up to the function on the stack
  call +_
;  ld hl,(opstack_ptr)
  inc hl
  ld (opstack_ptr),hl
  ret
_:

exec_multibyte:
exec_open_parens:
exec_open_list:
exec_if:
exec_while:
exec_for:
exec_raw:
exec_full:
exec_clrdraw:
exec_clrhome:
exec_dispgraph:
exec_text:
exec_putsprite:
exec_getkey:
exec_pixelon:
exec_pixeloff:
exec_pixeltoggle:
exec_pixeltest:
exec_int:
exec_ln:
exec_exp:
exec_sqrt:
exec_pause:
exec_disp:
exec_fix:
exec_sto:
exec_eq:
exec_neq:
exec_le:
exec_ge:
exec_lt:
exec_gt:
exec_add:
exec_sub:
exec_mul:
exec_div:
exec_neg:
exec_pow:
;pop off ops and evaluate until op has lower precedence
  push af
  call getprecedence
  jr z,opeval
;here we have a function
;So we need to push it to the operator stack
;And then we need to push a null byte to the operand stack to indicate the end
;of the arguments for the function (for when we need to evaluate the function).

#ifdef STACK_SAFE
  ld hl,(operandstack_top)
  ld bc,(operandstack_ptr)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
  ld a,type_param_end
  ld (bc),a
  inc bc
  ld (operandstack_ptr),bc
#else
  ld hl,(operandstack_ptr)
  ld (hl),type_param_end
  inc hl
  ld (operandstack_ptr),hl
#endif

  ld hl,(opstack_ptr)
  dec hl
  ld (opstack_ptr),hl
  pop af
  ld (hl),a

  ret

exec_close_parens:
;need to evaluate up to the open parens or function
  call end_arg
  jr eval_func

end_arg:
  ld hl,(opstack_ptr)
  ld a,(hl)
  inc hl
  call getprecedence
  cp 254
  call c,eval_func
  jr c,end_arg
  ret

opeval:
  call opstackprecedence
  jr nc,opeval
;push the operator
  dec hl
  dec hl
  ld (opstack_ptr),hl
  pop af
  ld (hl),a
  ret

opstackprecedence:
;Input:
;   A is the precedence of the input operator.
;   HL points to the first byte of the operator to compare to.
;Output:
;   nc if the input operator is of greater or equal precedence
;   HL points to the next operator
  push af
  ld hl,(opstack_ptr)
  ld a,(hl)
  inc hl
  call getprecedence
  ld b,a
  pop af
  cp b
  ret c

eval_func:
  push af

  ld de,(opstack_ptr)
  ld a,(de)
  or a
  scf
  ret z
  ld (opstack_ptr),hl

  ld c,a
#ifdef ALIGN_COMMAND_TABLE

  ld h,evalLUT>>8
  add a,a
  ld l,a
  jr nc,+_
  inc h
_:
#else
  ld hl,evalLUT
  ld b,0
  add hl,bc
  add hl,bc
#endif

  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld a,c
  call call_hl
  pop af
  ret

call_hl:
  jp (hl)

getprecedence:
;A is the first byte of the operator
;HL points to the next byte(s), if any
  push hl
  ld bc,(precedenceLUT_end-precedenceLUT)/2
  ld hl,precedenceLUT
_:
  cpi
  jr z,+_
  inc hl
  jp pe,-_
_:
  ;we have a match
  ld a,(hl)
  pop hl
  ret
precedenceLUT:
  .db 0,255   ;highest precedence
  .db $2B,-3  ;comma
  .db $6A,30  ;=
  .db $6F,30  ;!=
  .db $6B,32  ;<
  .db $6C,32  ;>
  .db $6D,32  ;<=
  .db $6E,32  ;>=
  .db $B0,41  ;(-)
  .db $F0,47  ;^
  .db $83,48  ;division
  .db $82,49  ;multiplication
  .db $71,50  ;subtraction
  .db $70,51  ;addition
  .db $04,-2  ;sto

precedenceLUT_end:
  .db -2

type_size_LUT:
  .db 1   ; 00 end of params
  .db 2   ; 01 ui8
  .db 3   ; 02 ui16
  .db 5   ; 03 ui32
  .db 3   ; 04 fixed88
  .db 5   ; 05 fixed1616
  .db 2   ; 06 var
  .db 1   ; 07 true
  .db 1   ; 08 false
  .db 5   ; 09 tstr_ref
  .db 0   ; 0A raw
  .db 0   ; 0B str
  .db 5   ; 0C str_ref
  .db 5   ; 0D single
  .db 11  ; 0E xfloat
  .db 0   ; 0F list
  .db 5   ; 10 list_ref
  .db 2   ; 11 char
  .db 7   ; 12 ref

type_size_LUT_end:

exec_close_list:
; There is a special case to take care of!
; In the event of [stuff][index], we need to check if the next char to be parsed
; is a '['. If so, need to store t_open_index instead of t_open_list
;
; As well, ']' can match '[' or t_open_index.
; If it is an index:
;     If the previous arg was a temp list, replace it with the sublist.
;     Else replace the previous arg with an index variable, {t_index,t_var,.dw #, .dw upper, .dw lower}
; Else need to allocate space for the list
;     '[' is stored like a function, so find the start of the "function"
;     arguments in the operandstack.
;     Have to work backwards, also get the size of each element (needs to be
;     evaluated)

  call end_arg

; Make sure the opstack has a `[` on it
  ld hl,(opstack_ptr)
  ld a,(hl)
  inc hl
  ld (opstack_ptr),hl
  cp tok_index
  jp z,exec_close_index
  cp $06
  jp nz,err_syntax


; Initialize the list field (and set it to size 0)
  ld hl,(heap_ptr)
  ld (hl),type_list
  inc hl
  xor a
  ld (hl),a
  inc hl
  ld (hl),a
  inc hl
  ld (hl),a
  inc hl
  ld (hl),a
  inc hl
  ld (heap_ptr),hl
  ld h,a
  ld l,a
  ld (temp_word_1),hl

  ld hl,(heap_top)
  push hl
  jr write_list_start
write_list_loop:
  ld hl,temp_word_1
  inc (hl)
  jr nz,+_
  inc hl
  inc (hl)
_:
  call pop_operand
  pop hl
  or a
  sbc hl,bc
  push hl
  ;make sure HL>=heap_ptr
  push de
  ld de,(heap_ptr)
  add a,1   ;resets carry flag and sets A to the type
  sbc hl,de
  jp c,err_mem
  add hl,de
  pop de

  ld (hl),a
  push hl
  ld hl,type_size_LUT
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  pop hl
  or a
  jr nz,+_
  ;need to write the size bytes still
  pop hl
  ld a,(hl)
  dec hl
  dec hl
  dec hl
  ld (hl),a
  push hl
  inc hl
  ld (hl),c
  inc hl
  ld (hl),b
  inc bc
_:
  cpi
  jp po,write_list_start
  ex de,hl

  ldir

write_list_start:
  call is_end_of_args
  jr nz,write_list_loop

  ;pop off the end-of-args
  ld (operandstack_ptr),hl

  pop hl    ;start of the list data
  ld de,(temp_word_1)   ;number of elements
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ex de,hl

  ld hl,(heap_top)
  or a
  sbc hl,de
  ld b,h
  ld c,l
  ld hl,(heap_ptr)
  dec hl
  dec hl
  dec hl
  dec hl
  push hl
  push bc
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ex de,hl
  ldir
  ex de,hl
  ld (heap_ptr),hl
  pop bc
  pop de
  dec de
  ld a,type_list_ref
  call pushoperand_ref
  jp check_if_index

exec_close_index:
  call popoperand_ui16
  push de
  call is_end_of_args
  jp nz,err_syntax
  ld (operandstack_ptr),hl
  call pop_operand
  pop hl    ;the index
  cp type_str-1
  jr z,exec_str_index
  cp type_str_ref-1
  jr z,exec_str_ref_index
  cp type_list-1
  jr z,exec_list_index
  cp type_list_ref-1
  jr z,exec_list_ref_index
  jp err_syntax

exec_list_ref_index:
  ld b,h
  ld c,l
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld h,b
  ld l,c
  inc de
  inc de
  inc de
exec_list_index:
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ex de,hl
;make sure HL<BC
  ; or a
  sbc hl,bc
  jp nc,err_bad_index
  add hl,bc
  ld b,h
  ld c,l
  ex de,hl
  jr list_index_start
list_index_loop:
  call next_list_element
  dec bc
list_index_start:
  ld a,b
  or c
  jr nz,list_index_loop
  ;HL points to the var
  call pushoperand_type_ref
  jp check_if_index

exec_str_ref_index:
  push hl
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  pop hl
exec_str_index:
;make sure HL<BC-1
  dec bc
  ; or a
  sbc hl,bc
  jp nc,err_bad_index
  add hl,bc
  add hl,de
  ld a,(hl)
  jp pushoperand_char

exec_num:
  ex de,hl
  dec de
  call atoui32

  ;make sure it isn't supposed to be a float!
  jr z,+_
  ;HLIX
  ld (parsePtr),de
  push ix
  pop de
  ld a,h
  or l
  jp z,pushoperand_ui16
  ex de,hl
  jp pushoperand_ui32
_:
  ;If it got this far, we actually have a float or a fixed-point number
  ;BC points to the number
  ;Default to an xfloat
  ld h,b
  ld l,c
  ld bc,OP1
  call strtox_p0

  ;save the parsePtr
  ld hl,(strtox_ptr)
  ld (parsePtr),hl

; allocate space on the stack for an xfloat
pushoperand_xfloat:
;BC points to the float

#ifdef STACK_SAFE
  ld de,(operandstack_ptr)
  ld hl,(operandstack_top)
  or a
  sbc hl,de
  ;if HL<11, oh no!
  ld a,l
  sub 11
  ld a,h
  sbc a,0
  jp c,err_operand_stack_overflow
#endif
  ld h,b
  ld l,c
  call mov10_p0
  ex de,hl
  ld (hl),type_xfloat
  inc hl
  ld (operandstack_ptr),hl
  ret

exec_rand:
  ld bc,xOP1
  call xrand_p0
  jp pushoperand_xfloat

exec_pi:
  ld de,(operandstack_ptr)
  ld a,X_CONST_PI
  call xconst_to_p0
  ex de,hl
  ld (hl),type_xfloat
  inc hl
  ld (operandstack_ptr),hl
  ret

exec_BB:
  ld a,(hl)
  cp $31    ;e token
  jr z,exec_e

; Check if it is lowercase
  cp $B0
  jr c,+_
  cp $CB
  jp c,exec_var_pre
_:


  jp ErrBadToken

exec_e:
  inc hl
  ld (parsePtr),hl
  ld de,(operandstack_ptr)
  ld a,X_CONST_e
  call xconst_to_p0
  ex de,hl
  ld (hl),type_xfloat
  inc hl
  ld (operandstack_ptr),hl
  ret

eval_internal:
  ld hl,(opstack_ptr)
  ld a,(hl)
  inc hl
  ld (opstack_ptr),hl
  ;A is the actual function to execute
  ld hl,eval_func_p1
  ld (next_page_call_address),hl
  jp next_page_call

eval_dispgraph:
;might have 0 or 1 argument
;assume 0 for now
  call pop_end_of_params
  jp GraphToLCD

eval_clrdraw:
;might have 0 or 1 argument
;assume 0 for now
  call pop_end_of_params
  ld hl,gbuf
  jp zeromem768

eval_clrhome:
  call pop_end_of_params
  bcall(_HomeUp)
  bcall(_ClrScrnFull)
  ret

eval_full:
  call pop_end_of_params
  in a,(2)
  add a,a
  sbc a,a
  out (20h),a
  ret

eval_pause:
;Pause might have 0 or 1 argument
;assume 0 for now
  call pop_end_of_params

_:
  bit OnBlockFlag,(iy+UserFlags)
  call z,CheckStatus
  call z,err_ON
  call GetKeyDebounce
  cp 9
  jr nz,-_
_:
  bit OnBlockFlag,(iy+UserFlags)
  call z,CheckStatus
  call z,err_ON
  call GetKeyDebounce
  or a
  jr nz,-_
  ret

eval_int:
  call popoperand_ui32
  push de
  push hl
  call pop_end_of_params
  pop hl
  pop de
  ld a,d
  or e
  jp z,pushoperand_ui16_HL
  jp pushoperand_ui32

eval_sqrt:
;Ideally, we'd want to be more clever about the type.
;If input is an integer and output is an integer, we'd want to keep it that way.
  call popoperand_xfloat
  push hl
  call pop_end_of_params
  pop hl

  ld bc,(operandstack_ptr)
  call xsqrt_p0
  jp push_special_xfloat

eval_ln:
  call popoperand_xfloat
  push hl
  call pop_end_of_params
  pop hl

  ld bc,(operandstack_ptr)
  call xln_p0
  jp push_special_xfloat

eval_exp:
  call popoperand_xfloat
  push hl
  call pop_end_of_params
  pop hl

  ld bc,(operandstack_ptr)
  call xexp_p0
  jp push_special_xfloat

push_special_xfloat:
;WARNING: This routine assumes there is enough space on the operand stack!
;Hypothetically, multiplying a ui32 and fixed1616 will need to pop off only 10
;bytes and push on 11. Or combos that include type_var can be a pain.
  ld hl,10
  add hl,bc
  ld (hl),type_xfloat
  inc hl
  ld (operandstack_ptr),hl
  ret

eval_fix:
  call popoperand_ui8
  inc a
  cp 20
  dec a
  jp nc,err_syntax
  ld (fmtDigits),a
  jp pop_end_of_params

eval_disp:
  call popoperand_str
  call PutS_
  bcall(_NewLine)
  jp pop_end_of_params

_:
  bcall(_PutC)
PutS_:
  ld a,(hl)
  or a
  inc hl
  jr nz,-_
  ret


eval_open_parens:
;make sure there is one operand
  ld de,(operandstack_ptr)
  ld hl,(operandstack_bottom)
  or a
  sbc hl,de
  jp z,err_too_few_args
  ld b,h
  ld c,l
;-BC is the number of bytes left in the operand stack

  dec de
  ld a,(de)
  or a
  jp z,err_too_few_args
  ; cp type_size_LUT_end-type_size_LUT
  ; jp nc,err_fatal      ;this means that there is a var allocated of a type not recognized

  ld hl,type_size_LUT
  add a,l
  ld l,a
  jr nc,+_
  inc h
_:

;Make sure that there are enough bytes for a final operand
  ld a,c
  add a,(hl)
  ld c,a
  jr nc,+_
  inc b
_:
  or b
  jp z,err_too_few_args
  ; inc b
  ; dec b
  ; jp z,err_fatal      ;this means that there was a misallocated var on the operand stack

  xor a
  ld b,a
  ld c,(hl)
  ex de,hl
  sbc hl,bc

;make sure that the operand is indeed a null byte
  cp (hl)
  call nz,err_too_many_args

;There is exactly one arg, so we'll shift BC bytes at HL+1, down to HL
  ld d,h
  ld e,l
  inc hl
  ldir
  ld (operandstack_ptr),de
  ret


;Need to evaluate the function pop the 0x00 off the operator stack and evaluate

eval_getkey:
  ld hl,(operandstack_ptr)
  dec hl
  xor a
  cp (hl)
  jr z,returnkeycode
  call popoperand_ui8
  push af
  call pop_end_of_params
  pop af
  call CheckKey
  jp pushoperand_bool_z

returnkeycode:
  call pop_end_of_params
  call GetKey
  jp pushoperand_ui8


eval_text:
  ld a,2
  ld (text_mode),a
  call popoperand_str
  push hl
  call popoperand_coord
  ld (text_row),bc
  call pop_end_of_params

  ld hl,gbuf
  ld (gbuf_temp),hl

  pop hl
  jp PutS


eval_putsprite:
  ; call countargs
  ; cp 5
  ld de,gbuf
  ; call z,popoperand_buf
  ld (gbuf_temp),de

  call popoperand_ui8     ;method
  push af

  call popoperand_coord
  push bc

  call popoperand_sprite
  ex de,hl
  pop bc
  pop af
  ld hl,$0801
  call sprite

  jp pop_end_of_params

eval_pixelon:
  call eval_pixel
  ret nc
  or (hl)
  ld (hl),a
  ret

eval_pixeloff:
  call eval_pixel
  ret nc
  cpl
  and (hl)
  ld (hl),a
  ret

eval_pixeltoggle:
  call eval_pixel
  ret nc
  xor (hl)
  ld (hl),a
  ret

eval_pixeltest:
  call eval_pixel
  jp nc,pushoperand_bool_c
  and (hl)
  add a,255
  jp pushoperand_bool_c


eval_pixel:
  call popoperand_coord
  push bc
  call is_end_of_args
  ld de,gbuf
  call nz,popoperand_buf
  ld (gbuf_temp),de
  call pop_end_of_params
  pop bc
#include "gfx/GetPixelLoc.z80"


eval_if:
  call popoperand_bool
  jp nz,pop_end_of_params
  ; We need to check THEN, ELSE, END stuff
  ld hl,(parsePtr)
  call seek_EOL
  jp pop_end_of_params

eval_while:
;need to
  ; call popoperand_bool
  ; jp z,seek_End

  jp ErrBadToken

eval_repeat:
eval_for:
eval_goto:
eval_lbl:
  jp ErrBadToken

eval_raw:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  call is_type_numeric
  jr z,eval_raw_size

  call popoperand_str
  push hl
  call pop_end_of_params
  pop de
;  ld hl,(operandstack_ptr)
  push hl
  call ConvHex
  pop bc
  or a
  sbc hl,bc
  push hl
  add hl,bc
  pop bc
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (hl),type_raw
  inc hl
  ld (operandstack_ptr),hl
  ret
eval_raw_size:
  call popoperand_ui16
  ld a,d
  or e
  call z,err_bad_input
  push de
  call pop_end_of_params
  pop bc
  add hl,bc
  inc hl
  inc hl
  ;make sure hl<operandstack_top
  ld de,(operandstack_top)
  or a
  sbc hl,de
  jp nc,err_stack_overflow_push
  dec hl
  dec hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (hl),type_raw
  inc hl
  ld (operandstack_ptr),hl
  sbc hl,bc   ;carry is set, so this does an extra decrement, helpfully.
  ;now write BC 0s. BC>0
  xor a
_:
  ld (hl),a
  cpi
  jp pe,-_
  ret
is_type_numeric:
  cp type_ui8
  ret z
  cp type_ui16
  ret z
  cp type_ui32
  ret z
  cp type_xfloat
  ret z
  cp type_single
  ret z
  cp type_fixed88
  ret z
  cp type_fixed1616
  ret


ConvHex:
  ld bc,$0A30
ConvHexLoop:
;  HL points to where to convert
;  DE is where to convert from
;  BC is 0A30
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  inc hl
  jp ConvHexLoop


eval_sto:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  cp type_ref
  jr z,sto_by_ref

  call popoperand_var
  add a,a
  ld hl,pvars
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ;HL points to the var's pointer
  push hl
  call pop_operand
  ld hl,eval_sto_LUT
  jp jumptableindex

sto_by_ref:
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  ld (operandstack_ptr),hl
  ;DE points to the value to overwrite
  ex de,hl
  call get_element_info
  ;HL points to data
  ;BC is the size of the data
  ;A is the var type

  push hl
  push bc
  call sto_by_ref_pop
  ;HL points to the data
  ;BC is the size of the data
  ex (sp),hl
  or a
  sbc hl,bc
  jp c,err_bad_type
  ld h,a
  ld a,b
  or c
  ld a,h
  pop hl
  pop de
  jr z,+_
  ldir
  ret
_:
;if the type is a bool, need to decrement DE and overwrite
  cp type_true
  jr z,+_
  cp type_false
  ret nz
_:
  dec de
  ld (de),a
  ret

get_element_info:
;Input:
;   HL points to the element.
;Outputs:
;   HL points to the data
;   BC is the size of the data
;   A is the var type
  ld a,(hl)
  ld de,type_size_LUT
  add a,e
  ld e,a
  jr nc,$+3
  inc d
  ld a,(de)
  or a
  jr z,get_variable_size_element_info
  ld c,a
  ld b,0
  ld a,(hl)
  inc hl
  ret
get_variable_size_element_info:
  ld a,(hl)
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ret

sto_by_ref_pop:
;Input: A is the type to pop to if possible
;Outputs: HL points to the data, BC is the size of the data
  cp type_ui8
  jr z,sto_by_ref_pop_ui8
  cp type_ui16
  jr z,sto_by_ref_pop_ui16
  cp type_ui32
  jr z,sto_by_ref_pop_ui32
  cp type_xfloat
  jr z,sto_by_ref_pop_xfloat
  cp type_str
  jr z,sto_by_ref_pop_str
  cp type_str_ref
  jr z,sto_by_ref_pop_str
  cp type_tstr_ref
  jr z,sto_by_ref_pop_str
  jp err_bad_type

sto_by_ref_pop_ui8:
  call popoperand_ui8
  ld hl,OP1
  ld (hl),a
  ld bc,1
  ret
sto_by_ref_pop_ui16:
  call popoperand_ui16
  ld hl,OP1+1
  ld (hl),d
  dec hl
  ld (hl),e
  ld bc,2
  ret
sto_by_ref_pop_ui32:
  call popoperand_ui32
  ld (OP1),hl
  ld (OP1+2),de
  ld hl,OP1
  ld bc,4
  ret
sto_by_ref_pop_xfloat:
  call popoperand_xfloat
  ld bc,10
  ret

sto_by_ref_pop_str:
  call popoperand_str
  push hl
  call stringlength
  pop hl
  ret

sto_temp:
;Need to create a temp var and set HL as its pointer
;For now, we are only allowing 4 temp vars
  ex de,hl
  ld a,(temp_var_count)
  inc a
  ld (temp_var_count),a
  and 3
  add a,50
  add a,a
  ld hl,pvars
  add a,l
  ld l,a
  jr nc,$+3
  inc h

  ld (hl),e
  inc hl
  ld (hl),d
  ret

dealloc_data:
;HL points to the data to deallocate
;This means that all vars need to have their pointers adjusted
  ret

alloc:
;Inputs:
;   BC is the number of bytes to allocate
;Outputs:
;   HL points to the allocated space
;   BC is preserved
;Destroys:
;   DE, F
  ld hl,(heap_ptr)
  add hl,bc
  jp c,err_heap_overflow
  ld de,(heap_top)
  or a
  sbc hl,de
  jp nc,err_heap_overflow
  add hl,de
  ld (heap_ptr),hl
  or a
  sbc hl,bc
  ret


eval_var:
  call popoperand_var
  ;gets the var number in A
  ;the var is a pointer to the actual data
  call getvar_ui16
  ex de,hl
  ld a,(hl)
  inc hl
  push af
  cp type_ui16
  jr z,eval_var_ui16
  cp type_raw
  jp nz,err_syntax
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  push bc
  ex de,hl
  jp pushoperand_ref

eval_var_ui16:
  ld e,(hl)
  inc hl
  ld d,(hl)
  jp pushoperand_ui16

getvar_ui16:
  add a,a
  ld hl,pvars
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
;HL points to the var data
  ld a,(hl)
  inc hl
  cp type_ui16
  jp nz,err_syntax
  ld e,(hl)
  inc hl
  ld d,(hl)
  ret

exec_var_pre:
  ld a,$BB
exec_var:
; Check if it is a built-in function or variable
  call get_func
  jr z,exec_function

  call get_var_by_name  ;returns HL pointing to the byte after the name, A is its index
  ld (parsePtr),hl
  call pushoperand_var

check_if_index:
  ld hl,(parsePtr)
  ld a,(hl)
  cp $06
  ret nz
  inc hl
  ld (parsePtr),hl
  ld a,tok_index
  jp exec_open_list

exec_function:
;HL pointing to the byte after the name
;DE points to the func data
  ld a,(de)
  add a,a
  jr nc,exec_function_is_var
  push af
;it is a function, so make sure that we have parens
  ld a,(hl)
  cp 16
  jp nz,err_missing_open_parens
  inc hl
  ld (parsePtr),hl
  ld a,tok_internal
  call exec_multibyte
  ld hl,(opstack_ptr)
  ld a,(hl)
  dec hl
  ;need to verify that this doesn't overlap
  ld (hl),a
  ld (opstack_ptr),hl
  inc hl
  pop af
  rrca
;A is the func number
  ld (hl),a
  ret

exec_function_is_var:
  ld (parsePtr),hl
  ex de,hl
  jp push_operand

get_func:
;Input: A is the first byte of te name, HL points to the next
;Output: HL pointing to the byte after the name, DE points to the func data

;Since we are only allowing alphanumerics, we'll use a fast, custom routine
;so that we don't need to use a bcall to convert tokens to ASCII
;Allowed to be numeric for internal functions and vars
  call tok_to_alnum
  jp c,err_bad_name
  ld de,(parsePtr)
  push de
  ld (parsePtr),hl
  ld (temp_word_1),a    ;first byte of the var name
  ld b,h
  ld c,l
  ld hl,(internal_vars_LUT_end-internal_vars_LUT)/2
  ld ix,get_internal_var_by_name_cmp
  call binarysearch
  pop hl
  ld (parsePtr),hl
  ret nz
  ;var or function was found
  ld de,(temp_word_3)
  ld hl,(temp_word_2)
  ret


get_var_by_name:
;Input: A is the first byte of te name, HL points to the next
;Output: HL pointing to the byte after the name, A is its index

;For now, keeping it really simple
;smallEditRam can only store 54 pointers

;Since we are only allowing alphanumerics, we'll use a fast, custom routine
;so that we don't need to use a bcall to convert tokens to ASCII
  call tok_to_alnum
  jp c,err_bad_name

;Make sure the first char is alphabetic (not numeric)
  cp '9'+1
  jp c,err_bad_name

  ld (parsePtr),hl

  call +_
  cp 54
  ret c
  jp err_mem
_:
;saveSScreen has the table
  ld (temp_word_1),a    ;first byte of the var name
  ld b,h
  ld c,l
  ld hl,(vars_count)
  ld ix,get_var_by_name_cmp
  call binarysearch
  jr nz,var_not_found
  ;var was found, assume the index is safe
  ld a,(temp_word_1+1)
  ld hl,(temp_word_2)
  ret

var_not_found:
;However, DE is what the index should have been.
  ld hl,(var_names_base)     ;pointer to the LUT of var names
  add hl,de
  add hl,de
  ;HL points to where to insert two bytes
  ld de,(var_names_ptr)
  ;WARNING! Need to make sure there is enough space avaialable!
  ;need to move DE-HL bytes from DE-1 to DE+1
  ;or a
  ex de,hl
  sbc hl,de
  ld b,h
  ld c,l
  add hl,de
  ld d,h
  ld e,l
  dec hl
  inc de
  push de
  jr z,+_
  lddr
_:
  pop hl
  inc hl
  ex de,hl
  ld (hl),d
  dec hl
  ld (hl),e

;Now, DE is where to write the name, but we also need to adjust all of the
;var name pointers less than DE by +2.
  ld bc,(vars_count)
  inc bc
  ld (vars_count),bc
  ld hl,(var_names_base)
var_names_adjust_loop:
  ;now we read the pointers, any less than DE are incremented by 2
  ld a,(hl)
  cp e
  inc hl
  ld a,(hl)
  sbc a,d
  jr nc,+_
  dec hl
  ld a,(hl)
  add a,2
  ld (hl),a
  inc hl
  jr nc,+_
  inc (hl)
_:
  cpi
  jp pe,var_names_adjust_loop

; Finally, we copy the string at parsePtr to DE, converting to ASCII
  ld a,(temp_word_1)
  ld hl,(parsePtr)
_:
  ld (parsePtr),hl
  ld (de),a
  inc de
  ld a,(hl)
  inc hl
  call tok_to_alnum
  jr nc,-_
  ex de,hl
  xor a
  ld (hl),a
  inc hl

;Now we write it's index
  ld de,(vars_count)
  dec de
  ld (hl),e
  inc hl
  ; ld (hl),d   ;only allowing <256 vars for now
  ; inc hl

;Now save var_names_ptr
  ld (var_names_ptr),hl

;Finally, we need to zero-out t bytes at the end of the var ptr LUT.

  ld hl,pvars
  add hl,de
  add hl,de
  ld (hl),a
  inc hl
  ld (hl),a
  ld hl,(parsePtr)
  ld a,e
  ret

get_internal_var_by_name_cmp:
  ld bc,internal_vars_LUT
  jr +_
get_var_by_name_cmp:
;HL is the input
;DE is the var to match
;If match, save the end of the input in temp_word_2 and index in temp_word_1+1
;
; Make sure the first byte matches
  ld bc,(var_names_base)
_:
  ex de,hl
  add hl,hl
  add hl,bc
  ld c,(hl)
  inc hl
  ld h,(hl)
  ld l,c
  ld a,(temp_word_1)
  cp (hl)
  ret nz

; The first byte matches, so now we need to compare the rest of the bytes
_:
  ex de,hl
  inc de
  ld a,(hl)
  ld b,h
  ld c,l
  inc hl
  call tok_to_alnum
  ex de,hl
  jr c,end_of_input
  cp (hl)
  jr z,-_
  ;this means it didn't match
  ret

end_of_input:
  ;now make sure (HL) is 0
  xor a
  cp (hl)
  ret nz
  ;we found a match, let's save the end-of-name
  ld (temp_word_2),bc
  ;save the index in temp_word_1+1
  inc hl
  ld a,(hl)
  ld (temp_word_1+1),a
  ;save HL
  ld (temp_word_3),hl
  ret

tok_to_alnum:
;If it is a lowercase token, it will start with $BB
;return nc if it is alphanumeric
  cp $BB
  jr z,tok_to_alnum_BB

;Now check if it is a number
  cp '0'
  ret c
  cp '9'+1
  ccf
  ret nc    ;quits here since it is a number

;Now check if it is uppercase
  cp 'A'
  ret c
  cp 'Z'+2
  ccf
  ret

tok_to_alnum_BB:
;We only need the lowercase letters
  ld a,(hl)
  inc hl
  cp $B0
  ret c
  cp $CB
  ccf
  ret c
  cp $BB
  adc a,'a'-$B0-1
  ccf
  ret


exec_var_index:
  inc hl
  ld (parsePtr),hl
  ;Need to push the var to the
  ret

get_var_type:
  dec hl
get_var_ptr:
;returns z if it is a null pointer
  ld a,(hl)
  add a,a
  ld hl,pvars
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  ld a,(hl)
  ret

eval_neg:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  ld c,a
  cp type_var
  call z,peekvar
  ld a,c
  ld hl,eval_neg_LUT
  jp jumptableindex

eval_eq:
  ld hl,eval_eq_LUT
  jp mathop

eval_neq:
  ld hl,eval_neq_LUT
  jp mathop

eval_gt:
  ld hl,eval_gt_LUT
  jp mathop

eval_lt:
  ld hl,eval_lt_LUT
  jp mathop

eval_ge:
  ld hl,eval_ge_LUT
  jp mathop

eval_le:
  ld hl,eval_le_LUT
  jp mathop

eval_add:
  ld hl,eval_add_LUT
  jp mathop

eval_sub:
  ld hl,eval_sub_LUT
  jp mathop

eval_mul:
  ld hl,eval_mul_LUT
  jp mathop

eval_div:
  ld hl,eval_div_LUT
  jp mathop

eval_pow:
  ld hl,eval_pow_LUT
  jp mathop

mathop:
  push hl
  call peekoperand_2
  call math_max_type
  pop hl
jumptableindex:
;HL points to the LUT that maps types to routines
;A is the type of the first operand
;C is the type of the second operand

;First, make sure A does not exceed the size of the LUT
  cp (hl)
  call nc,err_bad_type
  rla     ;c is set, so this does 2A+1 --> A
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  jp (hl)

math_max_type:
;The name of this wil likey change, I can't remember the proper terminology.
;Basically, float + int should return float, for example.
;
;Input:
;   A and C are the input types
;Output:
;   A and C are updated
;
  cp c
  ret z

  ld b,a

  ld a,type_str
  cp b \ ret z \ cp c \ ret z
  ; ld a,type_tstr
  ; cp b \ ret z \ cp c \ ret z
  ld a,type_str_ref
  cp b \ ret z \ cp c \ ret z
  ld a,type_tstr_ref
  cp b \ ret z \ cp c \ ret z
  ld a,type_true
  cp b \ ret z \ cp c \ ret z
  ld a,type_false
  cp b \ ret z \ cp c \ ret z
  ld a,type_char
  cp b \ ret z \ cp c \ ret z

  ld a,type_xfloat
  cp c
  ret z
  cp b
  jr nz,+_
  ld c,a
  ret
_:

  ld a,type_single
  cp c
  ret z
  cp b
  jr nz,+_
  ld c,a
  ret
_:

;We have the following types left, and we know B != C
;   uint8
;   uint16
;   uint32
;   fixed88
;   fixed1616

;   uint8+x ==> x

  ld a,type_ui8
  cp b
  jr nz,+_
  ld a,c
  ret
_:

  ld a,type_ui8
  cp c
  jr nz,+_
  ld a,b
  ld c,a
  ret
_:

;uint16+uint32 ==> uint32 + uint32
;uint16+fixed__ ==> fixed1616 + fixed1616
  ld a,type_ui16
  cp b
  jr nz,+_
  ;C is either uint32 or fixed__
  ld a,c
  cp type_ui32
  ret z
  ld a,type_fixed1616
  ld c,a
  ret
_:

;uint32+fixed__ ==> xfloat+xfloat
  ld a,type_xfloat
  ld c,a
  ret

pop_end_of_params:
  call is_end_of_args
  call nz,err_too_many_params
  ld (operandstack_ptr),hl
  ret

is_end_of_args:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,type_param_end
  cp (hl)
  ret

peekoperand_2:
;A is the type of the first
;C is the type of the second
  ld hl,(operandstack_ptr)
  dec hl
  ld c,(hl)
  ld a,c
  cp type_var
  call z,peekvar
  ld de,type_size_LUT
  add a,e
  ld e,a
  jr nc,$+3
  inc d
  ld a,(de)
  or a
  jr z,variable_size
  ld e,a
  ld a,l
  sub e
  ld l,a
  jr nc,$+3
  dec h

  ld a,(hl)
  cp type_var
  jp z,get_var_type   ;destroys HL
  ret

peekoperand:
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  cp type_var
  ret nz
  call peekvar
  ld a,c
  ret

peekvar:
;preserve HL,A
  push hl
  call get_var_type
  ld c,a
  pop hl
  ld a,type_var
  ret

variable_size:
;For now, these have size bytes, might change in the future?
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  scf
  sbc hl,de
  ld a,(hl)
  ret

tokstr2ascii:
  ld a,e
  cp OP3&255
  jp nc,err_fatal
  push hl
  push bc
  push de
  bcall(_Get_Tok_Strng)
  ld hl,OP3
  pop de
  ldir
  pop bc
  pop hl
  ld a,(hl)
  call is2byte
  jr nz,+_
  cpi
  jp po,err_fatal
_:
  cpi
  jp pe,tokstr2ascii
  xor a
  ld (de),a
  ret

popoperand_var:
;pops the var number into A from the operand stack
#ifdef STACK_SAFE
  ld hl,(operandstack_ptr)
  ld de,(operandstack_bottom)
  dec hl
  scf
  sbc hl,de
  jp c,err_operand_stack_overflow_pop
#endif
  ld hl,(operandstack_ptr)
  dec hl
#ifdef STACK_SAFE
  ld a,(hl)
  cp type_var
  jp nz,err_bad_type
#endif
  dec hl
  ld a,(hl)
  ld (operandstack_ptr),hl
  ret


pop2operand_xfloat:
  call popoperand_xfloat
  ;move it to xOP3
  ld de,OP3
  call mov10_p0
  call popoperand_xfloat
  ld de,OP3
  ld bc,(operandstack_ptr)
  ret

pop2operand_single:
  call popoperand_single
  ;move it to xOP3
  ld de,xOP3
  call mov4_p0
  call popoperand_single
  ld de,xOP3
  ld bc,(operandstack_ptr)
  ret

popoperand_xfloat:
  ld hl,to_xfloat_LUT
  jp pop_to

popoperand_single:
  ld hl,to_single_LUT
  jp pop_to

popoperand_ui8:
  ld hl,to_ui8_LUT
  jp pop_to

popoperand_ui16:
  ld hl,to_ui16_LUT
  jp pop_to

popoperand_ui32:
  ld hl,to_ui32_LUT
  jp pop_to

popoperand_fixed88:
  ld hl,to_fixed88_LUT
  jp pop_to

popoperand_fixed1616:
  ld hl,to_fixed1616_LUT
  jp pop_to

pop2operand_ui16:
  call popoperand_ui16
  push de
  call popoperand_ui16
  ex de,hl
  pop de
  ret

popoperand_str:
;Returns HL pointing to the data
;        BC is the size of the data
  ld hl,to_str_LUT
  jp pop_to

popoperand_bool:
;pops a boolean into the zero flag, z means false, nz means true
  ld hl,to_bool_LUT
  jp pop_to

popoperand_sprite:
  jp popoperand_raw

popoperand_buf:
  jp popoperand_ui16

popoperand_coord:
;returns BC as the coord
  call pop2operand_ui16
  ld b,e
  ld c,l
  ret

popoperand_raw:
;Returns HL pointing to the data
;        BC is the size of the data
  ld hl,(operandstack_ptr)
  dec hl
  ld a,(hl)
  cp type_var
  jr z,popraw_var
  cp type_raw
  jp nz,err_bad_type

popraw_var:
  dec hl
  ld a,(hl)
  ld (operandstack_ptr),hl
  add a,a
  ld hl,pvars
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld a,(hl)
  cp type_raw
  jp nz,err_bad_type
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ret

pop_to:
  push hl
  call pop_operand
  pop hl
  jp jumptableindex


pop_operand:
; Need to pop off the operand stack
; leave with DE pointing to the start of the element data, A as the type-1, BC is the size
  ld de,(operandstack_ptr)
  dec de
  ld a,(de)
  cp type_var
  jr z,popvar_to
  cp type_ref
  jr z,popref_to
  ld c,a
  dec c
  ld hl,type_size_LUT
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  or a
  jr z,pop_to_variable_size
  ;need to do (DE-A+1))
  dec a
  ld b,a
  ld a,e
  sub b
  ld e,a
  jr nc,$+3
  dec d
  ld (operandstack_ptr),de
  ld a,c
  ld c,b
  inc c
  ld b,0
  ret

pop_to_variable_size:
  ex de,hl
  ld a,c
  dec hl
  ld b,(hl)
  dec hl
  ld c,(hl)
  or a
  sbc hl,bc
  ld (operandstack_ptr),hl
  ex de,hl
  ret

popref_to:
  ex de,hl
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  ld (operandstack_ptr),hl
  jr +_
popref_ref:
  ex de,hl
  ld e,(hl)
  inc hl
  ld e,(hl)
_:

  ld a,(de)
  inc de
  cp type_var
  jr z,popvar_ref
  cp type_ref
  jr z,popref_ref
  ld c,a
  dec c
  ld hl,type_size_LUT
  add a,l
  ld l,a
  jr nc,$+3
  inc h
  ld a,(hl)
  or a
  ld a,c
  ret nz
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ex de,hl
  ret
popvar_ref:
  jp err_fatal    ;we should never be pointing to this type

popvar_to:
  ex de,hl
  dec hl
  ld (operandstack_ptr),hl

  call get_var_ptr
  jp z,err_unknown
  inc hl
  ex de,hl
val_adjust_ptr:
  dec a
  cp type_list-1
  jr z,+_
  cp type_str-1
  jr z,+_
  cp type_raw-1
  ret nz
_:
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ex de,hl
  ret

push_operand:
;HL points to the value to push to the operand stack
;First, get the size
  ld a,(hl)
  ld de,type_size_LUT
  add a,e
  ld e,a
  jr nc,$+3
  inc d
  ld a,(de)
  or a
  jr z,push_operand_variable
  ;A is the number of bytes to push
  ld c,a
  ld b,0

  push hl
  ld hl,(operandstack_ptr)
  add hl,bc
  ex de,hl
  ld hl,(operandstack_top)
  sbc hl,de
  ;want HL>=DE
  pop hl
  jp c,err_stack_overflow_push

  ld de,(operandstack_ptr)
  ld a,(hl)   ;type byte
  cpi
  jp po,+_
  ldir
_:
  ld (de),a
  inc de
  ld (operandstack_ptr),de
  ret

push_operand_variable:
  ld a,(hl)
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ex de,hl

  cp type_str
  jr nz,+_
  ld a, type_str_ref
  jp pushoperand_ref
_:

  cp type_list
  jr nz,+_
  ld a, type_list_ref
  jp pushoperand_ref
_:



next_list_element:
  ld a,(hl)
  ld de,type_size_LUT
  add a,e
  ld e,a
  jr nc,$+3
  inc d
  ld a,(de)
  or a
  jr z,next_list_element_variable
  add a,l
  ld l,a
  ret nc
  inc h
  ret
next_list_element_variable:
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  add hl,de
  ret

pushoperand_var:
;pushes the index of a var to the operand stack
;A is the index
;
#ifdef STACK_SAFE
  ld bc,(operandstack_ptr)
  inc bc
  ld hl,(operandstack_top)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),a
  inc hl
  ld (hl),type_var
  inc hl
  ld (operandstack_ptr),hl
  ret

pushoperand_bool_c:
  ccf
pushoperand_bool_nc:
  ld a,type_true
  adc a,0
  jr +_
pushoperand_bool_nz:
  ld a,type_true
  jr nz,+_
  inc a
  jr +_
pushoperand_bool_z:
  ld a,type_true
  jr z,+_
  inc a
_:
#ifdef STACK_SAFE
  ld bc,(operandstack_ptr)
  ld hl,(operandstack_top)
  or a
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),a
  inc hl
  ld (operandstack_ptr),hl
  ret

pushoperand_ui16_BC:
  ld d,b
  ld e,c
  jr pushoperand_ui16


pushoperand_fixed88:
  ld a,type_fixed88
  jr pushoperand_2byte

pushoperand_type_ref:
;HL points to the item
  ld a,type_ref
  ex de,hl
  jr pushoperand_2byte

exec_ans:
  ld hl,(Ans)
pushoperand_ui16_HL:
  ex de,hl
pushoperand_ui16:
;pushes DE to the operand stack
#ifdef STACK_SAFE
  ld a,type_ui16
pushoperand_2byte:
  ld bc,(operandstack_ptr)
  inc bc
  inc bc
  ld hl,(operandstack_top)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (hl),a
  inc hl
  ld (operandstack_ptr),hl
  ret


pushoperand_char:
  ld d,type_char
  jr pushoperand_1_byte
pushoperand_ui8:
  ld d,type_ui8
pushoperand_1_byte:
;pushes A to the operand stack
;D is type
#ifdef STACK_SAFE
  ld bc,(operandstack_ptr)
  inc bc
  ld hl,(operandstack_top)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),a
  inc hl
  ld (hl),d
  inc hl
  ld (operandstack_ptr),hl
  ret

exec_quote:
;Gonna push a string-by-reference to the stack
  push hl
  call seek_EOS
  ld (parsePtr),hl
  pop de
  ld a,type_tstr_ref
pushoperand_ref:
;DE points to the start
;BC is the size
;A is the type
  push bc
#ifdef STACK_SAFE
  ld bc,(operandstack_ptr)
  inc bc
  inc bc
  inc bc
  inc bc
  ld hl,(operandstack_top)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (hl),a
  inc hl
  ld (operandstack_ptr),hl
  jp check_if_index


pushoperand_fixed1616:
  ld a,type_fixed1616
  jr +_
pushoperand_ui32:
;pushes DEHL to the operand stack
  ld a,type_ui32
_:
  push de
  ex de,hl
#ifdef STACK_SAFE
  ld bc,(operandstack_ptr)
  inc bc
  inc bc
  inc bc
  inc bc
  ld hl,(operandstack_top)
  scf
  sbc hl,bc
  jp c,err_operand_stack_overflow
#endif
  ld hl,(operandstack_ptr)
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (hl),a
  inc hl
  ld (operandstack_ptr),hl
  ret

GetKeyDebounce:
  ei
  halt
  call GetKey
  ld hl,k_save
  cp (hl)
  jr nz,newkeypress
;if the keys match, decrement k_count
  inc hl
  dec (hl)
  jr z,+_
  xor a
  ret
_:
  inc hl
  ld a,(hl)
  sub K_DELAY_ACCEL+1
  jr nc,+_
  xor a
_:
  inc a
  ld (hl),a
  dec hl
  ld (hl),a
  dec hl
  ld a,(hl)
  ret
newkeypress:
  ld (hl),a
  inc hl
  ld (hl),K_DELAY_DEFAULT
  inc hl
  ld (hl),K_DELAY_DEFAULT
  ret
;===============================================================
GetKey:
;===============================================================
;Outputs:
;     a is a value from 0 to 56 that is the keypress
;    bc is also the key press
;     d has a bit reset, the rest are set (this is the last key group tested)
;     e is a with a mask of %11111000
;    hl is not modified
;===============================================================
  di
  ld de,$FE00
  ld a,d
  out (1),a
  push af \ pop af
  in a,(1)
  ld b,e
  xor $FF \ jr z,+_
  ld d,a
  ld c,16 \ cp 15 \ ret z
  ld c,5
  ld a,3 \ and d \ cp 3 \ ret z \ inc c
  ld a,5 \ and d \ cp 5 \ ret z \ inc c
  ld a,10 \ and d \ cp 10 \ ret z \ inc c
  ld a,12 \ and d \ cp 12 \ ret z
  ld a,d
  cpl
  ld c,e
  jp key_add
_:
  ld c,a
_:
  rlc d
  ld a,d
  out (1),a
  inc e
  sub 7Fh
  jp z,CheckOnPress
  in a,(1)
  inc a
  jr z,-_
  dec a
key_add:
  inc c
  rra
  jr c,key_add
  ld a,e
  rlca \ rlca \ rlca
  add a,c
  ld c,a
  ret
CheckOnPress:
  call CheckStatus
  ret nz
  ld c,41
  ret

CheckKey:
;Input:
;     A is the key to test for
;Output:
;     z if the key is pressed, nz if not
  call diRestore
  cp 41 ;on-key
  jp z,CheckStatus
_:
  dec a \ and 63
  ld b,a
  and 7
  srl b \ srl b \ srl b
  inc b \ inc a
;b = 2; a = 1
  ld c,a
  ld a,7Fh
_:
  rlca
  djnz -_
  out (1),a
  ld b,c
  ld a,80h
_:
  rlca
  djnz -_
  ld c,a
  in a,(1)
  and c
  ret

isStartMenu_valid:
  ld a,(OP1+1)
  cp $23
  jr z,StartMenu_invalid
  cp $21
  jr z,StartMenu_invalid

; Discard appvars for now
  ld a,(OP1)
  cp $15
  jr z,StartMenu_invalid


  ld hl,(VATPtr)
  ld a,(hl)
  cp 1        ;don't want lists
  jr nz,+_
StartMenu_invalid:
  or a
  ret
_:
  cp 13       ;don't want complex lists
  jr z,StartMenu_invalid
  cp 17h      ;don't want GroupVars
  jr z,StartMenu_invalid

  bit 6,(iy+UserFlags)     ;must be AppV
  jr z,+_
  cp 15h
  ret nz
_:
;need to pull in six bytes
#ifdef include_LoadTSA
  call LoadReadArc
#endif
  ld bc,-3
  add hl,bc
  ld e,(hl)
  dec hl
  ld d,(hl)
  dec hl
  ld a,(hl)
  or a
  jr z,+_
  ld b,a
  dec hl
  ld a,(hl)
  add a,10
  add a,e
  ld e,a
  ld a,b
  jr nc,+_
  inc d
  jp po,+_
  inc a
  ld d,$40
_:
  ex de,hl
  ld de,cmdShadow
  ld bc,2
  call TSA
  ld bc,(cmdShadow)
  ;need to save A:HL, BC
  ld (temp_word_3),a
  ld (temp_word_4),bc
  ld (temp_word_5),hl
_:
  ld bc,4
  call TSA
  ld hl,cmdShadow+2
  bit OnBlockFlag,(iy+UserFlags)   ;ASM only
  jp nz,asm_header_only

; ;non-ASM and ASM alike
;   bit baseInput,(iy+UserFlags)
;   ret z   ;doesn't have any special filters

;must be a Parsnip Var
;header is $B0,$30,$3E
  ld a,(hl)
  cp $B0 \ ret nz
  inc hl \ ld a,(hl) \ cp $30 \ ret nz
  inc hl \ ld a,(hl) \ cp $3E \ ret

asm_header_only:
;first two bytes must be $BB,$6D
;
  ld a,(hl) \ cp $BB \ ret nz
  inc hl \ ld a,(hl) \ cp $6D \ ret nz
  bit baseInput,(iy+UserFlags)
  ret z
;next two bytes must be $55,$C9
;
  inc hl \ ld a,(hl) \ cp $55 \ ret nz
  inc hl \ ld a,(hl) \ cp $C9
  ret

#ifdef include_LoadTSA
ReadArc:
  call LoadReadArc
  jp TSA
#else
ReadArc = TSA
#endif
ReadArcData:
#ifdef include_loadTSA
  .dw ReadArcEnd-ReadArc-2
#endif
#include "readarc.z80"
ReadArcEnd:

ZeroMem768:
  ld bc,768
ZeroMem:
  ld a,b \ or c \ ld a,0
  push de
  call nz,SetMem
  pop bc
  ret
SetSmallMem:
  ld (hl),a
  inc hl
  djnz SetSmallMem
  ret
SetMem:
  ld (hl),a
  ld d,h
  ld e,l
  cpi
  ret po
  ex de,hl
ReadRam:
  ldir
  ret

SetSpeed:
  in a,(20h)
  ld b,a
  bit 1,c
  jr z,+_
  cpl
  and 1
  ld c,a
_:
  in a,(2)
  rlca
  and c
  out (20h),a
  ld c,b
  ld b,0
  ret

;===============================================================
GetParsnipStr:
;===============================================================
;Input:
;    HL points to the start of the string
;Outputs:
;     A is the value of the ending byte of the string
;    BC is the size of the string
;    HL points to the ending byte of the string
;     z flag is set
;===============================================================
  ld bc,0
_:
  inc hl
  inc bc
  ld a,(hl)
  cp 4 \ ret z
  cp 3Fh \ ret z
  cp 2Ah \ jr nz,-_
  inc hl
  ret
FindGVarData:
  ld hl,GVarData
  rst rMov9ToOP1
  bcall(_ChkFindSym)
  ret nc
  ld hl,3
  bcall(_CreateAppVar)
  ret

internal_vars_LUT:
  .dw internal_func_GETMODE   ;GETMODE
  .dw internal_func_SETMODE   ;SETMODE
  .dw internal_func_VERSION   ;VERSION
internal_vars_LUT_end:

internal_func_GETMODE:
  .db "GETMODE",0,128+0
internal_func_SETMODE:
  .db "SETMODE",0,128+1
internal_func_VERSION:
  .db "VERSION",0
  .db type_str_ref
  .dw StrVersion
  .dw StrVersion_end-StrVersion

#include "main.z80"
#include "progmeta.z80"
#include "ramcode.z80"
#include "routines.z80"
#include "isort.z80"
#include "SetUpData.z80"
#include "parserhook.z80"
#include "tokenhook.z80"

#ifdef include_LoadTSA
#include "cmd/loadtsa.z80"
#endif
PutSI:
;     The string to display immediately follows the call
;       The string is zero terminated
;Outputs:
;     All registers are preserved
  ex (sp),hl
  push de
  push bc
  push af
  call PutS
  inc hl
  pop af
  pop bc
  pop de
  ex (sp),hl
  ret
#include "gfx/text.z80"
DrawRectToGraphI:
  ex (sp),hl
;  push de \ push bc \ push af
  ld e,(hl) \ inc hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ld a,(hl) \ inc hl
  ex (sp),hl
DrawRectToGraph:
#include "gfx/drawrect.z80"
#include "gfx/bigsprite.z80"
#include "gfx/gbufToLCD.z80"
#include "subroutines/diRestore.z80"
#include "subroutines/CheckStatus.z80"
#include "subroutines/util.z80"
#include "subroutines/searchlabel.z80"
#include "parsnipdata.z80"
#include "math.z80"
#include "math/mul16.z80"
#include "math/BC_Div_DE_faster.z80"
#include "math/div16_continue.z80"
#include "math/division/divfixed_88.z80"
#include "math/multiplication/mulfixed_88.z80"
#include "conversion/itoa_16.z80"
#include "conversion/atoui32.z80"
#include "search/binarysearch.z80"
#include "utility/strcopy.z80"
#include "err.z80"



xconst_to_xOP1_p0:
  ld hl,xconst_to_xOP1
  ld (next_page_call_address),hl
  jp next_page_call

strtox_p0:
  ld de,strtox
  ld (next_page_call_address),de
  jp next_page_call

xtostr_p0:
  ld de,xtostr
  ld (next_page_call_address),de
  jp next_page_call

xrand_p0:
  ld ix,xrand
  ld (next_page_call_address),ix
  jp next_page_call


xmul_p0:
  ld ix,xmul
  ld (next_page_call_address),ix
  jp next_page_call

xdiv_p0:
  ld ix,xdiv
  ld (next_page_call_address),ix
  jp next_page_call

xadd_p0:
  ld ix,xadd
  ld (next_page_call_address),ix
  jp next_page_call

xsub_p0:
  ld ix,xsub
  ld (next_page_call_address),ix
  jp next_page_call

xcmp_p0:
  ld bc,xcmp
  ld (next_page_call_address),bc
  jp next_page_call

xneg_p0:
  ld de,xneg
  ld (next_page_call_address),de
  jp next_page_call

xsqrt_p0:
  ld de,xsqrt
  ld (next_page_call_address),de
  jp next_page_call

xln_p0:
  ld de,xln
  ld (next_page_call_address),de
  jp next_page_call

xexp_p0:
  ld de,xexp
  ld (next_page_call_address),de
  jp next_page_call

xpow_p0:
  ld ix,xpow
  ld (next_page_call_address),ix
  jp next_page_call

xinv_p0:
  ld de,xinv
  ld (next_page_call_address),de
  jp next_page_call

xconst_to_p0:
  ld hl,xconst_to
  ld (next_page_call_address),hl
  jp next_page_call


negSingle_p0:
  ld bc,negSingle
  ld (next_page_call_address),bc
  jp next_page_call

addSingle_p0:
  ld ix,addSingle
  ld (next_page_call_address),ix
  jp next_page_call

subSingle_p0:
  ld ix,subSingle
  ld (next_page_call_address),ix
  jp next_page_call

mulSingle_p0:
  ld ix,mulSingle
  ld (next_page_call_address),ix
  jp next_page_call

invSingle_p0:
  ld de,invSingle
  ld (next_page_call_address),de
  jp next_page_call

divSingle_p0:
  ld ix,divSingle
  ld (next_page_call_address),ix
  jp next_page_call

powSingle_p0:
  ld ix,powSingle
  ld (next_page_call_address),ix
  jp next_page_call

single2str_p0:
  ld de,single2str
  ld (next_page_call_address),de
  jp next_page_call

mulfixed16_16_p0:
  ld hl,mulfixed16_16
  ld (next_page_call_address),hl
  jp next_page_call


#include "ops/add.z80"
#include "ops/sub.z80"
#include "ops/mul.z80"
#include "ops/div.z80"
#include "ops/sto.z80"
#include "ops/eq.z80"
#include "ops/neq.z80"
#include "ops/le.z80"
#include "ops/ge.z80"
#include "ops/lt.z80"
#include "ops/gt.z80"
#include "ops/neg.z80"
#include "ops/sqr.z80"
#include "ops/inv.z80"
#include "ops/cubed.z80"
#include "ops/pow.z80"
#include "convert/to_xfloat.z80"
#include "convert/to_single.z80"
#include "convert/to_ui8.z80"
#include "convert/to_ui16.z80"
#include "convert/to_ui32.z80"
#include "convert/to_fixed88.z80"
#include "convert/to_fixed1616.z80"
#include "convert/to_str.z80"
#include "convert/to_bool.z80"

#include "commandtable.z80"
.echo "Page 0: ",$8000-$," bytes remaining"

; .fill $8000-$,255
.fill $8000-$,0
#include "01.z80"
.echo "RamCode : ",RamCodeEnd-RamCodeStart, " bytes"
