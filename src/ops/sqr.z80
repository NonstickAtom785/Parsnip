eval_sqr_LUT:
  .db (+_-$-1)/2
  .dw err_syntax      ;should not have run out of args!
  .dw sqr_ui8
  .dw sqr_ui16
  .dw sqr_ui32
  .dw sqr_fixed88
  .dw sqr_fixed1616
  .dw sqr_var
  .dw sqr_true
  .dw sqr_false
  .dw sqr_tstr_ref
  .dw sqr_raw
  .dw sqr_str
  .dw sqr_str_ref
  .dw sqr_single
  .dw sqr_xfloat
_:


sqr_ui8:
sqr_ui16:
sqr_ui32:
sqr_fixed88:
sqr_fixed1616:
sqr_var:
sqr_true:
sqr_false:
sqr_tstr_ref:
sqr_raw:
sqr_str:
sqr_str_ref:
  call popoperand_ui16
  ld b,d
  ld c,e
  call DE_Times_BC
  ld a,d
  or e
  jp nz,pushoperand_ui32
  jp pushoperand_ui16_HL

sqr_single:
  call popoperand_single
  ld d,h
  ld e,l
  ld bc,(operandstack_ptr)
  call mulSingle_p0
;WARNING: This routine assumes there is enough space on the operand stack!
  ld hl,4
  add hl,bc
  ld (hl),type_single
  inc hl
  ld (operandstack_ptr),hl
  ret

sqr_xfloat:
  call popoperand_xfloat
  ld d,h
  ld e,l
  ld bc,(operandstack_ptr)
  call xmul_p0
;WARNING: This routine assumes there is enough space on the operand stack!
;Hypothetically, multiplying a ui32 and fixed1616 will need to pop off only 10
;bytes and push on 11. Or combos that include type_var can be a pain.
  ld hl,10
  add hl,bc
  ld (hl),type_xfloat
  inc hl
  ld (operandstack_ptr),hl
  ret
